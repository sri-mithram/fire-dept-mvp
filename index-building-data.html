<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Safety Command Center - Building Data</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Cesium for fallback -->
    <script src="https://ajax.googleapis.com/ajax/libs/cesiumjs/1.105/Build/Cesium/Cesium.js"></script>
    <link href="https://ajax.googleapis.com/ajax/libs/cesiumjs/1.105/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <!-- Google Maps API - For Geocoding -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyA9T-CN7O0wcnBcvo9Go9HuSxia_U1QdEA&v=beta&libraries=places,geometry&loading=async"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: white;
            min-height: 100vh;
            padding: 0;
            overflow-x: hidden;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* Top Navigation Bar */
        .nav-bar {
            background: linear-gradient(135deg, rgba(0, 153, 255, 0.2) 0%, rgba(0, 102, 204, 0.3) 100%);
            backdrop-filter: blur(20px);
            border-bottom: 2px solid rgba(0, 153, 255, 0.4);
            padding: 15px 30px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            position: relative;
        }

        .nav-tab {
            padding: 12px 30px;
            background: rgba(0, 153, 255, 0.1);
            border: 2px solid rgba(0, 153, 255, 0.3);
            border-radius: 12px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(255, 255, 255, 0.7);
            transition: all 0.3s ease;
        }

        .nav-tab:hover {
            background: rgba(0, 153, 255, 0.2);
            color: rgba(255, 255, 255, 0.9);
            transform: translateY(-2px);
        }

        .nav-tab.active {
            background: linear-gradient(135deg, rgba(0, 153, 255, 0.4) 0%, rgba(0, 102, 204, 0.5) 100%);
            border-color: rgba(0, 153, 255, 0.6);
            color: #0099FF;
            box-shadow: 0 4px 12px rgba(0, 153, 255, 0.4);
        }

        .main-content {
            flex: 1;
            display: flex;
            height: calc(100vh - 70px);
            overflow: hidden;
        }

        .content-view {
            display: none;
            width: 100%;
            height: 100%;
        }

        .content-view.active {
            display: flex;
        }

        .content-view:not(.active) {
            display: none !important;
            visibility: hidden !important;
        }

        /* Ensure tracking elements are completely hidden when transcription tab is active */
        .transcription-view.active ~ .tracking-view,
        body:has(.transcription-view.active) .tracking-view {
            display: none !important;
            visibility: hidden !important;
        }
        
        /* Ensure transcription elements are completely hidden when tracking tab is active */
        .tracking-view.active ~ .transcription-view,
        body:has(.tracking-view.active) .transcription-view {
            display: none !important;
            visibility: hidden !important;
        }

        .transcription-view {
            flex-direction: column;
            padding: 20px;
        }

        .tracking-view {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            padding: 15px;
            width: 100%;
            margin: 0 auto;
        }
        
        /* Center the building panel when no vitals are shown */
        .tracking-view:not(.with-o2-left):not(.with-pulse-right):not(.with-both-vitals) {
            display: flex;
            justify-content: center;
        }
        
        .tracking-view:not(.with-o2-left):not(.with-pulse-right):not(.with-both-vitals) .building-panel {
            width: 60%;
            max-width: 1200px;
        }

        .tracking-view.with-o2-left {
            display: grid;
            grid-template-columns: 1fr 2.5fr;
            gap: 20px;
        }

        .tracking-view.with-o2-left .pulse-panel {
            display: none !important;
        }
        
        .tracking-view.with-o2-left .o2-panel {
            grid-column: 1;
        }
        
        .tracking-view.with-o2-left .building-panel {
            grid-column: 2;
            width: 100%;
        }

        .tracking-view.with-pulse-right {
            display: grid;
            grid-template-columns: 2.5fr 1fr;
            gap: 20px;
        }

        .tracking-view.with-pulse-right .o2-panel {
            display: none !important;
        }
        
        .tracking-view.with-pulse-right .building-panel {
            grid-column: 1;
            width: 100%;
        }
        
        .tracking-view.with-pulse-right .pulse-panel {
            grid-column: 2;
        }

        .tracking-view.with-both-vitals {
            display: grid;
            grid-template-columns: 1fr 2.5fr 1fr;
            gap: 20px;
        }
        
        .tracking-view.with-both-vitals .o2-panel {
            grid-column: 1;
        }
        
        .tracking-view.with-both-vitals .building-panel {
            grid-column: 2;
            width: 100%;
        }
        
        .tracking-view.with-both-vitals .pulse-panel {
            grid-column: 3;
        }

        .container {
            max-width: 100%;
            width: 100%;
            height: 100%;
            margin: 0;
        }

        /* Transcription Panel */
        .transcription-panel {
            background: linear-gradient(135deg, rgba(0, 153, 255, 0.15) 0%, rgba(0, 102, 204, 0.25) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 40px;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            border: 2px solid rgba(0, 153, 255, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            height: 100%;
            max-width: 1400px;
            margin: 0 auto;
            width: 100%;
        }

        .section-title {
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 30px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(0, 153, 255, 0.5);
            color: #0099FF;
            position: relative;
            z-index: 2;
        }

        .mic-container {
            margin-bottom: 40px;
            position: relative;
            z-index: 2;
        }

        .mic-icon {
            width: 80px;
            height: 80px;
            background: linear-gradient(135deg, #ffffff 0%, #e6f3ff 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 153, 255, 0.3);
            transition: transform 0.2s ease;
        }

        .mic-icon:hover {
            transform: scale(1.05);
        }

        .mic-shape {
            width: 20px;
            height: 35px;
            background: #0099FF;
            border-radius: 15px 15px 0 0;
            position: relative;
        }

        .mic-shape::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 8px;
            background: #0099FF;
            border-radius: 50%;
        }

        .transcription-text {
            flex: 1;
            width: 100%;
            overflow-y: auto;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 15px;
            border: 1px solid rgba(0, 153, 255, 0.2);
            font-size: 16px;
            line-height: 1.8;
            color: rgba(255, 255, 255, 0.9);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            margin-bottom: 20px;
            position: relative;
            z-index: 2;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            position: relative;
            z-index: 2;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.listening {
            background: #00ff00;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Building Panel */
        .building-panel {
            background: linear-gradient(135deg, rgba(0, 153, 255, 0.15) 0%, rgba(0, 102, 204, 0.25) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 25px;
            border: 2px solid rgba(0, 153, 255, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        .address-input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .address-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid rgba(0, 153, 255, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 14px;
        }

        .address-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .address-button {
            padding: 12px 25px;
            background: linear-gradient(135deg, #0099FF 0%, #0077CC 100%);
            border: none;
            border-radius: 10px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .address-button:hover {
            transform: scale(1.05);
        }

        .address-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .building-container {
            flex: 1;
            width: 100%;
            min-height: 600px;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .building-title {
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(0, 153, 255, 0.5);
            color: #0099FF;
        }

        #buildingCanvas {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            background: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(0, 153, 255, 0.3);
            display: block;
            cursor: grab;
            position: relative;
            z-index: 1;
        }

        #buildingCanvas:active {
            cursor: grabbing;
        }

        #cesiumContainer {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            border: 2px solid rgba(0, 153, 255, 0.3);
            display: none;
            overflow: hidden;
            position: relative;
            box-sizing: border-box;
        }

        #cesiumContainer canvas {
            width: 100% !important;
            height: 100% !important;
            border-radius: 15px;
        }

        .cesium-viewer-toolbar,
        .cesium-viewer-bottom {
            display: none;
        }

        .data-source-indicator {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px 15px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            font-size: 12px;
            color: #00ff00;
            z-index: 100;
            border: 1px solid rgba(0, 153, 255, 0.5);
        }

        .street-view-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 45px;
            height: 45px;
            background: rgba(0, 153, 255, 0.8);
            border: 2px solid rgba(0, 153, 255, 0.5);
            border-radius: 8px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }

        .street-view-toggle:hover {
            background: rgba(0, 153, 255, 1);
            transform: scale(1.1);
        }

        .street-view-toggle::before {
            content: 'ðŸ“·';
            font-size: 24px;
        }

        .street-view-expanded {
            position: absolute;
            top: 10px;
            right: 10px;
            width: calc(100% - 20px);
            height: calc(100% - 20px);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid rgba(0, 153, 255, 0.5);
            border-radius: 15px;
            z-index: 2000;
            display: none;
            flex-direction: column;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        .street-view-expanded.active {
            display: flex;
        }

        .street-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            color: white;
        }

        .street-view-header h3 {
            margin: 0;
            font-size: 18px;
            color: #0099FF;
        }

        .street-view-close {
            width: 35px;
            height: 35px;
            background: rgba(255, 0, 0, 0.7);
            border: 2px solid rgba(255, 0, 0, 0.5);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .street-view-close:hover {
            background: rgba(255, 0, 0, 1);
            transform: scale(1.1);
        }

        .street-view-iframe-container {
            flex: 1;
            border-radius: 10px;
            overflow: hidden;
        }

        #street-view {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            border: 1px solid rgba(0, 153, 255, 0.3);
            overflow: hidden;
        }

        .zoom-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 1000;
            pointer-events: auto;
        }

        .zoom-button {
            width: 40px;
            height: 40px;
            background: rgba(0, 153, 255, 0.8);
            border: 2px solid rgba(0, 153, 255, 0.5);
            border-radius: 8px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            user-select: none;
        }

        .zoom-button:hover {
            background: rgba(0, 153, 255, 1);
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0, 153, 255, 0.5);
        }

        .zoom-button:active {
            transform: scale(0.95);
        }

        .zoom-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .zoom-button:disabled:hover {
            transform: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        /* Vitals Panels */
        .vitals-panel {
            background: linear-gradient(135deg, rgba(0, 153, 255, 0.15) 0%, rgba(0, 102, 204, 0.25) 100%);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 20px;
            border: 2px solid rgba(0, 153, 255, 0.4);
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            display: none;
            flex-direction: column;
            height: 100%;
        }

        .vitals-panel.active {
            display: flex;
        }

        /* O2 Panel (left side) */
        .o2-panel {
            order: 1;
        }

        /* Pulse Panel (right side) */
        .pulse-panel {
            order: 3;
        }

        /* Building Panel (center) */
        .building-panel {
            order: 2;
        }

        /* Critical Alert Popup */
        .critical-alert {
            position: fixed;
            top: 100px;
            right: 20px;
            background: linear-gradient(135deg, rgba(255, 0, 0, 0.9) 0%, rgba(200, 0, 0, 0.95) 100%);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 15px;
            padding: 20px 25px;
            min-width: 350px;
            max-width: 450px;
            box-shadow: 0 8px 32px rgba(255, 0, 0, 0.6), 0 0 20px rgba(255, 0, 0, 0.8);
            z-index: 10000;
            animation: alertPulse 2s infinite;
            display: none;
        }

        .critical-alert.active {
            display: block;
        }

        .critical-alert.warning {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.9) 0%, rgba(255, 140, 0, 0.95) 100%);
            box-shadow: 0 8px 32px rgba(255, 165, 0, 0.6), 0 0 20px rgba(255, 165, 0, 0.8);
        }

        @keyframes alertPulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 8px 32px rgba(255, 0, 0, 0.6), 0 0 20px rgba(255, 0, 0, 0.8);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 10px 40px rgba(255, 0, 0, 0.8), 0 0 30px rgba(255, 0, 0, 1);
            }
        }

        .critical-alert-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .critical-alert-title {
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .critical-alert-close {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .critical-alert-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .critical-alert-content {
            font-size: 16px;
            line-height: 1.6;
        }

        .critical-alert-person {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid rgba(255, 255, 255, 0.8);
        }

        .critical-alert-value {
            font-size: 24px;
            font-weight: bold;
            color: #ffffff;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }

        .alerts-container {
            position: fixed;
            top: 100px;
            right: 20px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 15px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }

        .vitals-section-title {
            font-size: 20px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 3px;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 2px 10px rgba(0, 153, 255, 0.5);
            color: #0099FF;
        }

        .meters-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 1;
            align-items: stretch;
            justify-content: flex-start;
        }

        .meter {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 18px;
            padding: 10px;
            border: 2px solid rgba(0, 153, 255, 0.3);
            display: flex;
            flex-direction: column;
            width: 100%;
        }

        .meter-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
            text-shadow: 0 2px 5px rgba(0, 153, 255, 0.5);
        }

        .personnel-list {
            margin-top: 5px;
            flex: 1;
            overflow-y: auto;
        }

        .personnel-item {
            font-size: 12px;
            padding: 4px 8px;
            margin: 3px 0;
            background: rgba(0, 153, 255, 0.15);
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            border: 1px solid rgba(0, 153, 255, 0.2);
        }

        .unit-group-label {
            font-size: 12px;
            font-weight: bold;
            color: #0099FF;
            margin: 10px 0 4px 0;
            padding: 4px 8px;
            background: rgba(0, 153, 255, 0.1);
            border-radius: 6px;
            border-left: 3px solid #0099FF;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <!-- Top Navigation Bar -->
    <nav class="nav-bar">
        <div class="nav-tab active" id="transcriptionTab">Transcription</div>
        <div class="nav-tab" id="trackingTab">Tracking</div>
    </nav>

    <!-- Main Content Area -->
    <div class="main-content">
        <!-- Transcription View -->
        <div class="content-view transcription-view active" id="transcriptionView">
            <div class="container">
                <div class="transcription-panel">
                    <div class="section-title">Transcription</div>
                    <div class="mic-container">
                        <div class="mic-icon" id="micIcon">
                            <div class="mic-shape"></div>
                        </div>
                    </div>
                    <div class="transcription-text" id="transcriptionText"></div>
                    <div class="status-indicator">
                        <div class="status-dot" id="statusDot"></div>
                        <span id="statusText">Ready to Listen</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tracking View -->
        <div class="content-view tracking-view" id="trackingView">
            <div class="building-panel">
                <div class="address-input-container">
                    <input 
                        type="text" 
                        class="address-input" 
                        id="addressInput" 
                        placeholder="Enter building address"
                    >
                    <button class="address-button" id="loadAddressBtn">Load Building</button>
                </div>
                <div class="building-container">
                    <div class="building-title">Tracking</div>
                    <div class="data-source-indicator" id="dataSourceIndicator" style="display: none;">
                        Data Source: <span id="dataSourceText">-</span>
                    </div>
                    <div class="street-view-toggle" id="streetViewToggle" title="View Street View"></div>
                    <canvas id="buildingCanvas"></canvas>
                    <div id="cesiumContainer"></div>
                    <div class="zoom-controls">
                        <button class="zoom-button" id="zoomInBtn" title="Zoom In">+</button>
                        <button class="zoom-button" id="zoomOutBtn" title="Zoom Out">âˆ’</button>
                    </div>
                    <div class="street-view-expanded" id="streetViewExpanded">
                        <div class="street-view-header">
                            <h3>Street View</h3>
                            <button class="street-view-close" id="streetViewClose">Ã—</button>
                        </div>
                        <div class="street-view-iframe-container" id="streetViewIframeContainer">
                            <div id="street-view"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- O2 Vitals Panel (left side, only shows when O2 critical thresholds are breached) -->
            <div class="vitals-panel o2-panel" id="o2Panel">
                <div class="vitals-section-title">Oxygen Levels Alert</div>
                <div class="meters-panel">
                    <div class="meter">
                        <div class="meter-title">Oxygen Levels</div>
                        <div class="personnel-list" id="oxygenList"></div>
                        <div style="margin-top: 10px; font-size: 11px; opacity: 0.7; text-align: center;">
                            Threshold: 95% SpO2
                        </div>
                    </div>
                </div>
            </div>

            <!-- Pulse Vitals Panel (right side, only shows when pulse critical thresholds are breached) -->
            <div class="vitals-panel pulse-panel" id="pulsePanel">
                <div class="vitals-section-title">Pulse Monitor Alert</div>
                <div class="meters-panel">
                    <div class="meter">
                        <div class="meter-title">Pulse Monitor</div>
                        <div class="personnel-list" id="pulseList"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Critical Alerts Container -->
    <div class="alerts-container" id="alertsContainer"></div>

    <script>
        // ============================================
        // INITIALIZATION
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            initApp();
        });

        function initApp() {
            // ============================================
            // SPEECH RECOGNITION / TRANSCRIPTION
            // ============================================
            const transcriptionText = document.getElementById('transcriptionText');
            const micIcon = document.getElementById('micIcon');
            const statusDot = document.getElementById('statusDot');
            const statusText = document.getElementById('statusText');

            let recognition = null;
            let isListening = false;

            if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';

                recognition.onstart = () => {
                    isListening = true;
                    micIcon.classList.add('listening');
                    statusDot.classList.add('listening');
                    statusText.textContent = 'Listening...';
                };

                recognition.onresult = (event) => {
                    let finalTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        if (event.results[i].isFinal) {
                            finalTranscript += event.results[i][0].transcript + ' ';
                        }
                    }
                    if (finalTranscript) {
                        const span = document.createElement('span');
                        span.className = 'word';
                        span.textContent = finalTranscript;
                        transcriptionText.appendChild(span);
                        transcriptionText.scrollTop = transcriptionText.scrollHeight;
                    }
                };

                recognition.onerror = (event) => {
                    console.error('Speech recognition error:', event.error);
                };

                recognition.onend = () => {
                    isListening = false;
                    micIcon.classList.remove('listening');
                    statusDot.classList.remove('listening');
                    statusText.textContent = 'Stopped';
                };
            } else {
                statusText.textContent = 'Speech Recognition not supported';
                micIcon.style.opacity = '0.5';
            }

            micIcon.addEventListener('click', () => {
                if (!recognition) return;
                if (isListening) {
                    recognition.stop();
                } else {
                    recognition.start();
                }
            });

            // ============================================
            // THREE.JS / BUILDING VISUALIZATION
            // ============================================
            const canvas = document.getElementById('buildingCanvas');
            const addressInput = document.getElementById('addressInput');
            const loadAddressBtn = document.getElementById('loadAddressBtn');
            const dataSourceIndicator = document.getElementById('dataSourceIndicator');
            const dataSourceText = document.getElementById('dataSourceText');
            const streetViewToggle = document.getElementById('streetViewToggle');
            const streetViewExpanded = document.getElementById('streetViewExpanded');
            const streetViewClose = document.getElementById('streetViewClose');
            const streetViewIframeContainer = document.getElementById('streetViewIframeContainer');
            const streetViewContainer = document.getElementById('street-view');
            
            let streetViewPanorama = null;

            let scene, camera, renderer, buildingGroup;
            let personnelObjects = [];
            let personnelPerFloor = [];
            let cesiumViewer = null;
            let currentAddress = null;
            let currentLocation = null;
            
            // Mouse drag controls for building rotation
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            let rotationY = 0;
            let rotationX = 0.3; // Initial tilt
            let buildingCenterHeight = 8; // Default building center height for camera lookAt
            let cameraRadius = 25; // Camera distance from building center for rotation
            let minCameraRadius = 8; // Minimum zoom (closest)
            let maxCameraRadius = 100; // Maximum zoom (farthest)

            function initThreeJS() {
                const width = canvas.clientWidth || 800;
                const height = canvas.clientHeight || 600;

                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x001122);
                scene.fog = new THREE.Fog(0x001122, 100, 1000);

                camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.set(15, 12, 20);
                camera.lookAt(0, 5, 0);

                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x0099FF, 0.4);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(20, 30, 10);
                directionalLight.castShadow = true;
                scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0x0099FF, 0.6, 100);
                pointLight.position.set(0, 15, 0);
                scene.add(pointLight);

                // Ground
                const groundGeometry = new THREE.PlaneGeometry(50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x112233,
                    emissive: 0x000011
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.5;
                ground.receiveShadow = true;
                scene.add(ground);

                buildingGroup = new THREE.Group();
                scene.add(buildingGroup);

                // Mouse drag controls for building rotation
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const deltaX = e.clientX - previousMousePosition.x;
                        const deltaY = e.clientY - previousMousePosition.y;
                        
                        rotationY += deltaX * 0.01;
                        rotationX = Math.max(0, Math.min(Math.PI / 2, rotationX - deltaY * 0.01));
                        
                        previousMousePosition = { x: e.clientX, y: e.clientY };
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                canvas.addEventListener('mouseleave', () => {
                    isDragging = false;
                });

                // Mouse wheel zoom controls
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    // Adjust zoom based on wheel delta
                    const zoomSpeed = 0.1;
                    const zoomDelta = e.deltaY * zoomSpeed;
                    
                    // Zoom in/out by adjusting camera radius
                    // Positive deltaY = scroll down = zoom out (increase radius)
                    // Negative deltaY = scroll up = zoom in (decrease radius)
                    cameraRadius += zoomDelta;
                    
                    // Clamp zoom to min/max limits
                    cameraRadius = Math.max(minCameraRadius, Math.min(maxCameraRadius, cameraRadius));
                    if (window.updateZoomButtons) window.updateZoomButtons();
                }, { passive: false });

                // Zoom button controls
                const zoomInBtn = document.getElementById('zoomInBtn');
                const zoomOutBtn = document.getElementById('zoomOutBtn');

                // Make updateZoomButtons accessible globally
                window.updateZoomButtons = function() {
                    if (!zoomInBtn || !zoomOutBtn) return;
                    // Enable/disable buttons based on zoom limits
                    zoomInBtn.disabled = cameraRadius <= minCameraRadius;
                    zoomOutBtn.disabled = cameraRadius >= maxCameraRadius;
                };

                function zoomIn() {
                    const zoomStep = 5; // Increased step size for more noticeable zoom
                    cameraRadius = Math.max(minCameraRadius, cameraRadius - zoomStep);
                    if (window.updateZoomButtons) window.updateZoomButtons();
                }

                function zoomOut() {
                    const zoomStep = 5; // Increased step size for more noticeable zoom
                    cameraRadius = Math.min(maxCameraRadius, cameraRadius + zoomStep);
                    if (window.updateZoomButtons) window.updateZoomButtons();
                }

                zoomInBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    zoomIn();
                });
                zoomOutBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    zoomOut();
                });

                // Initialize button states
                if (window.updateZoomButtons) window.updateZoomButtons();

                // Animation loop - will be controlled by setAnimationLoop when tracking view is active
                function animate() {
                    animatePersonnel();
                    
                    // Apply mouse rotation to camera
                    camera.position.x = Math.sin(rotationY) * Math.cos(rotationX) * cameraRadius;
                    camera.position.y = Math.sin(rotationX) * cameraRadius + buildingCenterHeight;
                    camera.position.z = Math.cos(rotationY) * Math.cos(rotationX) * cameraRadius;
                    camera.lookAt(0, buildingCenterHeight, 0);
                    
                    renderer.render(scene, camera);
                }
                
                // Only start animation if tracking view is active
                const trackingViewEl = document.getElementById('trackingView');
                if (trackingViewEl && trackingViewEl.classList.contains('active')) {
                    renderer.setAnimationLoop(animate);
                }

                // Handle resize
                window.addEventListener('resize', () => {
                    const width = canvas.clientWidth;
                    const height = canvas.clientHeight;
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                });
            }

            // Only initialize Three.js when tracking view is active
            let threeJSInitialized = false;

            function initThreeJSIfNeeded() {
                const trackingViewEl = document.getElementById('trackingView');
                if (!threeJSInitialized && trackingViewEl && trackingViewEl.classList.contains('active')) {
                    initThreeJS();
                    threeJSInitialized = true;
                }
            }

            // ============================================
            // CREATE BUILDING FROM DATA
            // ============================================
            // Helper function to convert color string to hex
            function parseColor(colorStr) {
                if (!colorStr) return null;
                
                // Handle named colors
                const namedColors = {
                    'red': 0xff0000, 'blue': 0x0000ff, 'green': 0x00ff00,
                    'yellow': 0xffff00, 'orange': 0xffa500, 'brown': 0xa52a2a,
                    'gray': 0x808080, 'grey': 0x808080, 'white': 0xffffff, 'black': 0x000000,
                    'tan': 0xd2b48c, 'beige': 0xf5f5dc, 'cream': 0xfffdd0
                };
                
                const lowerColor = colorStr.toLowerCase().trim();
                if (namedColors[lowerColor]) {
                    return namedColors[lowerColor];
                }
                
                // Handle rgb(r, g, b)
                const rgbMatch = colorStr.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1]);
                    const g = parseInt(rgbMatch[2]);
                    const b = parseInt(rgbMatch[3]);
                    return (r << 16) | (g << 8) | b;
                }
                
                // Handle hex #rrggbb or #rgb
                if (colorStr.startsWith('#')) {
                    const hex = colorStr.slice(1);
                    if (hex.length === 3) {
                        // Expand #rgb to #rrggbb
                        const r = parseInt(hex[0], 16) * 17;
                        const g = parseInt(hex[1], 16) * 17;
                        const b = parseInt(hex[2], 16) * 17;
                        return (r << 16) | (g << 8) | b;
                    } else if (hex.length === 6) {
                        return parseInt(hex, 16);
                    }
                }
                
                return null;
            }
            
            function createBuildingFromData(buildingData) {
                // Clear existing building
                while (buildingGroup.children.length > 0) {
                    buildingGroup.remove(buildingGroup.children[0]);
                }
                personnelObjects = [];
                personnelPerFloor = [];
                floorBounds = [];

                const floorHeight = 3; // meters per floor
                // PRIORITY: Use floors directly from buildingData (if available)
                // Fallback to calculating from height only if floors not provided
                const numFloors = buildingData.floors || Math.max(1, Math.floor((buildingData.height || 15) / floorHeight));
                const floorWidth = buildingData.width || 12;
                const floorDepth = buildingData.depth || 8;
                
                // Extract ONEGEO properties for rendering (if available)
                const onegeo = buildingData.onegeoProperties || {};
                
                // Parse colors for rendering
                const wallColor = parseColor(onegeo.color) || 0x4477AA; // Default blue-gray if no color
                const roofColor = parseColor(onegeo.roofColor) || 0x225588; // Default darker blue-gray
                
                // Adjust material properties based on building material
                let wallMetalness = 0.2;
                let wallRoughness = 0.8;
                if (onegeo.material) {
                    const material = onegeo.material.toLowerCase();
                    if (material.includes('glass')) {
                        wallMetalness = 0.1;
                        wallRoughness = 0.1;
                    } else if (material.includes('metal') || material.includes('steel')) {
                        wallMetalness = 0.7;
                        wallRoughness = 0.3;
                    } else if (material.includes('concrete')) {
                        wallMetalness = 0.1;
                        wallRoughness = 0.9;
                    } else if (material.includes('brick')) {
                        wallMetalness = 0.1;
                        wallRoughness = 0.85;
                    }
                }
                
                console.log('Rendering building:', {
                    floors: buildingData.floors,
                    height: buildingData.height,
                    numFloors: numFloors,
                    width: floorWidth,
                    depth: floorDepth,
                    usingFloorsDirectly: !!buildingData.floors,
                    wallColor: `0x${wallColor.toString(16)}`,
                    roofColor: `0x${roofColor.toString(16)}`,
                    buildingType: onegeo.type || 'Unknown',
                    hasONEGEOData: !!onegeo.levels
                });

                const floors = [];

                for (let i = 0; i < numFloors; i++) {
                    const yPos = i * floorHeight;

                    // Floor
                    const floorGeometry = new THREE.BoxGeometry(floorWidth, 0.2, floorDepth);
                    const floorMaterial = new THREE.MeshStandardMaterial({
                        color: 0x336699,
                        emissive: 0x001133,
                        metalness: 0.3,
                        roughness: 0.7
                    });
                    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                    floor.position.set(0, yPos, 0);
                    floor.receiveShadow = true;
                    buildingGroup.add(floor);

                    // Walls - use ONEGEO color if available
                    const wallMaterial = new THREE.MeshStandardMaterial({
                        color: wallColor,
                        emissive: (wallColor >> 16 & 0xFF) > 100 ? 0x000011 : 0x001122, // Darker emissive for lighter colors
                        metalness: wallMetalness,
                        roughness: wallRoughness,
                        transparent: true,
                        opacity: 0.7
                    });

                    const frontWall = new THREE.Mesh(
                        new THREE.BoxGeometry(floorWidth, floorHeight * 0.8, 0.1),
                        wallMaterial
                    );
                    frontWall.position.set(0, yPos + floorHeight * 0.4, floorDepth / 2);
                    frontWall.castShadow = true;
                    buildingGroup.add(frontWall);

                    const leftWall = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, floorHeight * 0.8, floorDepth),
                        wallMaterial
                    );
                    leftWall.position.set(-floorWidth / 2, yPos + floorHeight * 0.4, 0);
                    leftWall.castShadow = true;
                    buildingGroup.add(leftWall);

                    const rightWall = new THREE.Mesh(
                        new THREE.BoxGeometry(0.1, floorHeight * 0.8, floorDepth),
                        wallMaterial
                    );
                    rightWall.position.set(floorWidth / 2, yPos + floorHeight * 0.4, 0);
                    rightWall.castShadow = true;
                    buildingGroup.add(rightWall);

                    const floorBoundsData = {
                        y: yPos + 0.1,
                        minX: -floorWidth / 2 + 0.5,
                        maxX: floorWidth / 2 - 0.5,
                        minZ: -floorDepth / 2 + 0.5,
                        maxZ: floorDepth / 2 - 0.5
                    };
                    floors.push(floorBoundsData);
                    floorBounds.push(floorBoundsData);

                    // Create personnel for this floor
                    const numPersonnel = Math.max(1, Math.min(3, Math.floor(floorWidth * floorDepth / 20)));
                    personnelPerFloor.push(numPersonnel);

                    for (let j = 0; j < numPersonnel; j++) {
                        const personnel = createPersonnelFigurine();
                        const startX = floors[i].minX + Math.random() * (floors[i].maxX - floors[i].minX);
                        const startZ = floors[i].minZ + Math.random() * (floors[i].maxZ - floors[i].minZ);
                        personnel.position.set(startX, floors[i].y, startZ);

                        const waypoints = [];
                        for (let w = 0; w < 5; w++) {
                            waypoints.push({
                                x: floors[i].minX + Math.random() * (floors[i].maxX - floors[i].minX),
                                z: floors[i].minZ + Math.random() * (floors[i].maxZ - floors[i].minZ)
                            });
                        }

                        personnelObjects.push({
                            mesh: personnel,
                            floorIndex: i,
                            targetX: startX,
                            targetZ: startZ,
                            currentWaypoint: 0,
                            waypoints: waypoints,
                            speed: 0.015 + Math.random() * 0.02,
                            walkCycle: 0,
                            waypointReachedTime: Date.now(),
                            changeWaypointInterval: 3000 + Math.random() * 4000
                        });

                        buildingGroup.add(personnel);
                    }
                }

                // Roof - use ONEGEO roof color and account for roof height
                const roofHeight = onegeo.roofHeight || 0.3; // Use actual roof height if available
                const roofGeometry = new THREE.BoxGeometry(floorWidth + 0.5, roofHeight, floorDepth + 0.5);
                
                // Adjust roof material based on roof material type
                let roofMetalness = 0.5;
                let roofRoughness = 0.5;
                if (onegeo.roofMaterial) {
                    const roofMat = onegeo.roofMaterial.toLowerCase();
                    if (roofMat.includes('tile')) {
                        roofMetalness = 0.1;
                        roofRoughness = 0.8;
                    } else if (roofMat.includes('metal')) {
                        roofMetalness = 0.8;
                        roofRoughness = 0.2;
                    }
                }
                
                const roofMaterial = new THREE.MeshStandardMaterial({
                    color: roofColor,
                    emissive: (roofColor >> 16 & 0xFF) > 100 ? 0x000011 : 0x001122,
                    metalness: roofMetalness,
                    roughness: roofRoughness
                });
                const roof = new THREE.Mesh(roofGeometry, roofMaterial);
                roof.position.set(0, numFloors * floorHeight + roofHeight / 2, 0);
                roof.castShadow = true;
                buildingGroup.add(roof);
                
                // Store firefighter-relevant data for potential future use (e.g., info panel)
                if (onegeo.levels || onegeo.type || onegeo.name) {
                    buildingGroup.userData = {
                        firefighterInfo: {
                            name: onegeo.name,
                            type: onegeo.type,
                            levels: onegeo.levels,
                            height: buildingData.height,
                            roofShape: onegeo.roofShape,
                            roofHeight: onegeo.roofHeight,
                            roofDirection: onegeo.roofDirection ? `${onegeo.roofDirection.toFixed(1)}Â° (${getCardinalDirection(onegeo.roofDirection)})` : null,
                            area: onegeo.area,
                            built: onegeo.built,
                            material: onegeo.material
                        }
                    };
                }
                
                // Adjust camera to fit the building in view
                // Use setTimeout to ensure building is fully rendered
                setTimeout(() => {
                    adjustCameraForBuilding(numFloors, floorWidth, floorDepth, floorHeight);
                }, 100);
            }
            
            function adjustCameraForBuilding(numFloors, floorWidth, floorDepth, floorHeight) {
                if (!camera || !scene) return;
                
                // Calculate building dimensions
                const buildingHeight = numFloors * floorHeight + 0.3; // Include roof
                const buildingWidth = Math.max(floorWidth, floorDepth);
                
                // Update building center height for camera lookAt (used in rotation)
                buildingCenterHeight = buildingHeight * 0.4;
                
                // Calculate bounding sphere radius
                const diagonal = Math.sqrt(floorWidth * floorWidth + floorDepth * floorDepth);
                const maxDimension = Math.max(buildingHeight, diagonal);
                const boundingRadius = maxDimension * 0.8; // Add some padding
                
                // Calculate optimal camera distance
                const fov = camera.fov * (Math.PI / 180);
                const distance = boundingRadius / Math.sin(fov / 2);
                
                // Add extra distance to ensure building fits, but keep it closer
                // Store initial radius, but respect user zoom preferences
                const initialRadius = Math.max(distance * 0.9, 8); // Closer default zoom (0.9 instead of 1.5)
                
                // Only update cameraRadius if it's at default or if building is much larger
                // This preserves user's zoom level when possible
                if (cameraRadius === 25 || cameraRadius < initialRadius * 0.5 || cameraRadius > initialRadius * 2) {
                    cameraRadius = initialRadius;
                }
                
                // Update min/max limits based on building size
                minCameraRadius = Math.max(5, initialRadius * 0.3);
                maxCameraRadius = Math.max(50, initialRadius * 3);
                
                // Update zoom button states after limits change
                if (window.updateZoomButtons) window.updateZoomButtons();
                
                // Calculate initial rotation angles based on optimal camera position
                const angle = Math.PI / 6; // 30 degrees
                const heightOffset = buildingHeight * 0.7;
                
                // Calculate initial rotation angles from optimal position
                const initialX = cameraRadius * Math.cos(angle);
                const initialZ = cameraRadius * Math.sin(angle);
                const initialY = heightOffset + cameraRadius * 0.3;
                
                // Calculate initial rotationY and rotationX from position
                rotationY = Math.atan2(initialX, initialZ);
                const radiusXY = Math.sqrt(initialX * initialX + initialZ * initialZ);
                rotationX = Math.atan2(initialY - buildingCenterHeight, radiusXY);
                
                // Apply initial rotation
                camera.position.set(
                    Math.sin(rotationY) * Math.cos(rotationX) * cameraRadius,
                    Math.sin(rotationX) * cameraRadius + buildingCenterHeight,
                    Math.cos(rotationY) * Math.cos(rotationX) * cameraRadius
                );
                
                // Look at the center of the building
                camera.lookAt(0, buildingCenterHeight, 0);
                camera.updateProjectionMatrix();
                
                console.log('Camera adjusted:', {
                    radius: cameraRadius.toFixed(2),
                    position: {
                        x: camera.position.x.toFixed(2),
                        y: camera.position.y.toFixed(2),
                        z: camera.position.z.toFixed(2)
                    },
                    rotationY: rotationY.toFixed(2),
                    rotationX: rotationX.toFixed(2),
                    buildingCenterHeight: buildingCenterHeight.toFixed(2),
                    buildingHeight: buildingHeight.toFixed(2),
                    buildingWidth: buildingWidth.toFixed(2)
                });
            }

            function createPersonnelFigurine() {
                const personnel = new THREE.Group();
                const material = new THREE.MeshStandardMaterial({
                    color: 0xFFD700,
                    emissive: 0xFFA500,
                    emissiveIntensity: 0.3,
                    metalness: 0.5,
                    roughness: 0.5
                });

                // Head
                const head = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 12), material);
                head.position.set(0, 0.65, 0);
                personnel.add(head);

                // Body
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.4, 12), material);
                body.position.set(0, 0.25, 0);
                personnel.add(body);

                // Arms
                const armGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8);
                const leftArm = new THREE.Mesh(armGeo, material);
                leftArm.position.set(-0.2, 0.3, 0);
                leftArm.rotation.z = 0.3;
                personnel.add(leftArm);

                const rightArm = new THREE.Mesh(armGeo, material);
                rightArm.position.set(0.2, 0.3, 0);
                rightArm.rotation.z = -0.3;
                personnel.add(rightArm);

                // Legs
                const legGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.35, 8);
                const leftLeg = new THREE.Mesh(legGeo, material);
                leftLeg.position.set(-0.08, -0.15, 0);
                personnel.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeo, material);
                rightLeg.position.set(0.08, -0.15, 0);
                personnel.add(rightLeg);

                // Helmet
                const helmet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.18, 12, 12),
                    new THREE.MeshStandardMaterial({
                        color: 0xFF6600,
                        emissive: 0xFF3300,
                        emissiveIntensity: 0.8,
                        transparent: true,
                        opacity: 0.6
                    })
                );
                helmet.position.set(0, 0.65, 0);
                personnel.add(helmet);

                personnel.scale.set(0.8, 0.8, 0.8);
                personnel.traverse((child) => {
                    if (child.isMesh) child.castShadow = true;
                });

                return personnel;
            }

            let floorBounds = [];

            function animatePersonnel() {
                const time = Date.now() * 0.001;
                personnelObjects.forEach((personnel, index) => {
                    const floor = floorBounds[personnel.floorIndex] || { minX: -5, maxX: 5, minZ: -4, maxZ: 4, y: 0.1 };

                    const now = Date.now();
                    if (now - personnel.waypointReachedTime > personnel.changeWaypointInterval) {
                        personnel.currentWaypoint = (personnel.currentWaypoint + 1) % personnel.waypoints.length;
                        const wp = personnel.waypoints[personnel.currentWaypoint];
                        personnel.targetX = wp.x;
                        personnel.targetZ = wp.z;
                        personnel.waypointReachedTime = now;
                        personnel.changeWaypointInterval = 3000 + Math.random() * 4000;
                    }

                    const dx = personnel.targetX - personnel.mesh.position.x;
                    const dz = personnel.targetZ - personnel.mesh.position.z;
                    const distance = Math.sqrt(dx * dx + dz * dz);

                    if (distance > 0.1) {
                        const speed = personnel.speed * (0.8 + Math.random() * 0.4);
                        personnel.mesh.position.x += dx * speed;
                        personnel.mesh.position.z += dz * speed;
                        personnel.mesh.rotation.y = Math.atan2(dx, dz) + (Math.random() - 0.5) * 0.1;
                    } else {
                        // Pick new random waypoint when reached
                        personnel.currentWaypoint = Math.floor(Math.random() * personnel.waypoints.length);
                        const wp = personnel.waypoints[personnel.currentWaypoint];
                        personnel.targetX = wp.x;
                        personnel.targetZ = wp.z;
                    }

                    // Keep within floor bounds
                    personnel.mesh.position.x = Math.max(floor.minX - 0.2, Math.min(floor.maxX + 0.2, personnel.mesh.position.x));
                    personnel.mesh.position.z = Math.max(floor.minZ - 0.2, Math.min(floor.maxZ + 0.2, personnel.mesh.position.z));

                    // Walking animation
                    personnel.mesh.position.y = floor.y + Math.sin(time * 3 + index) * 0.04;
                    personnel.walkCycle = (personnel.walkCycle || 0) + 0.2 + Math.random() * 0.1;

                    // Animate legs and arms
                    const legs = personnel.mesh.children.filter(child => 
                        child.position.y < 0 && child.geometry && child.geometry.type === 'CylinderGeometry'
                    );
                    const arms = personnel.mesh.children.filter(child => 
                        child.position.y > 0 && child.position.y < 0.5 && child.geometry && child.geometry.type === 'CylinderGeometry'
                    );

                    legs.forEach((leg, idx) => {
                        leg.rotation.x = Math.sin(personnel.walkCycle + idx * Math.PI) * (0.3 + Math.random() * 0.1);
                    });

                    arms.forEach((arm, idx) => {
                        arm.rotation.x = Math.sin(personnel.walkCycle + idx * Math.PI) * (0.2 + Math.random() * 0.1);
                    });
                });
            }

            // ============================================
            // DATA SOURCES
            // ============================================
            async function loadBuildingFromAddress(address) {
                try {
                    console.log('Loading building for address:', address);
                    setDataSource('Geocoding...');

                    // Geocode address
                    if (!window.google || !window.google.maps) {
                        throw new Error('Google Maps API not loaded');
                    }

                    const { Geocoder } = await google.maps.importLibrary("geocoding");
                    const geocoder = new Geocoder();

                    geocoder.geocode({ address: address }, async (results, status) => {
                        if (status !== 'OK' || !results[0]) {
                            alert('Address not found');
                            return;
                        }

                        const location = results[0].geometry.location;
                        const lat = location.lat();
                        const lng = location.lng();
                        
                        // Store current address and location for Street View
                        currentAddress = address;
                        currentLocation = { lat, lng };

                        console.log('Geocoded to:', lat, lng);

                        // Try ONEGEO first (best for height estimation)
                        try {
                            const onegeoData = await getONEGEOBuildingData(lat, lng, address);
                            if (onegeoData) {
                                setDataSource('ONEGEO');
                                createBuildingFromData(onegeoData);
                                canvas.style.display = 'block';
                                document.getElementById('cesiumContainer').style.display = 'none';
                                showStreetViewButton();
                                return;
                            }
                        } catch (error) {
                            console.log('ONEGEO failed, trying OSM:', error);
                        }

                        // Fallback to OSM
                        try {
                            const osmData = await getOSMBuildingData(lat, lng);
                            if (osmData) {
                                setDataSource('OpenStreetMap');
                                createBuildingFromData(osmData);
                                canvas.style.display = 'block';
                                document.getElementById('cesiumContainer').style.display = 'none';
                                showStreetViewButton();
                                return;
                            }
                        } catch (error) {
                            console.log('OSM failed, trying Microsoft:', error);
                        }

                        // Fallback to Microsoft Building Footprints
                        try {
                            const msftData = await getMicrosoftBuildingData(lat, lng);
                            if (msftData) {
                                setDataSource('Microsoft Building Footprints');
                                createBuildingFromData(msftData);
                                canvas.style.display = 'block';
                                document.getElementById('cesiumContainer').style.display = 'none';
                                showStreetViewButton();
                                return;
                            }
                        } catch (error) {
                            console.log('Microsoft failed, trying Google:', error);
                        }

                        // Final fallback to Google 3D Tiles
                        setDataSource('Google 3D Tiles');
                        await initCesium(lat, lng);
                        canvas.style.display = 'none';
                        document.getElementById('cesiumContainer').style.display = 'block';
                        showStreetViewButton();
                    });
                } catch (error) {
                    console.error('Error loading building:', error);
                    alert('Error loading building: ' + error.message);
                }
            }

            // Helper function to get cardinal direction from degrees
            function getCardinalDirection(degrees) {
                const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
                return directions[Math.round(degrees / 22.5) % 16];
            }

            async function getONEGEOBuildingData(lat, lng, address) {
                // ONEGEO API - Reference: https://onegeo.co/documentation/api/
                // Provides building data with height information from multiple sources
                // Note: Requires API key - get one at https://onegeo.co/api/#plans
                
                const ONEGEO_API_KEY = '9d89v7de8unauf9f'; // Replace with your API key
                
                try {
                    console.log('Attempting to fetch ONEGEO building data...');
                    
                    // Use bounding box approach (0.5 x 0.5 degree max extent)
                    const bboxSize = 0.002; // Small bbox around the location (about 220m)
                    const west = lng - bboxSize;
                    const south = lat - bboxSize;
                    const east = lng + bboxSize;
                    const north = lat + bboxSize;
                    const bbox = `${west},${south},${east},${north}`;
                    
                    // First, try by bounding box
                    let apiUrl = `https://data.onegeo.co/api/?token=${ONEGEO_API_KEY}&bbox=${bbox}`;
                    
                    let response = await fetch(apiUrl);
                    
                    // Check for API key issues
                    if (!response.ok) {
                        if (response.status === 401) {
                            console.warn('ONEGEO API key not configured. Using fallback sources.');
                            return null;
                        }
                        // If bbox fails, try address search as fallback (if we have an address)
                        if (address && response.status !== 401) {
                            const encodedAddress = encodeURIComponent(address);
                            apiUrl = `https://data.onegeo.co/api/?token=${ONEGEO_API_KEY}&search=${encodedAddress}`;
                            response = await fetch(apiUrl);
                            
                            if (!response.ok) {
                                if (response.status === 401) {
                                    console.warn('ONEGEO API key not configured. Using fallback sources.');
                                    return null;
                                }
                                throw new Error(`ONEGEO API failed: ${response.status}`);
                            }
                        } else if (!address || response.status === 401) {
                            if (response.status === 401) {
                                console.warn('ONEGEO API key not configured. Using fallback sources.');
                            }
                            return null;
                        } else {
                            throw new Error(`ONEGEO API failed: ${response.status}`);
                        }
                    }
                    
                    const data = await response.json();
                    
                    if (!data || !data.features || data.features.length === 0) {
                        console.log('No ONEGEO building data found');
                        return null;
                    }
                    
                    // Find closest building to the location
                    let closestBuilding = null;
                    let minDist = Infinity;
                    
                    data.features.forEach(feature => {
                        if (feature.geometry && feature.geometry.type === 'Polygon') {
                            // Calculate centroid of building polygon
                            const coords = feature.geometry.coordinates[0];
                            let sumLon = 0, sumLat = 0;
                            coords.forEach(coord => {
                                sumLon += coord[0];
                                sumLat += coord[1];
                            });
                            const centerLon = sumLon / coords.length;
                            const centerLat = sumLat / coords.length;
                            
                            // Haversine distance approximation
                            const dLat = (centerLat - lat) * 111000;
                            const dLon = (centerLon - lng) * 111000 * Math.cos(lat * Math.PI / 180);
                            const dist = Math.sqrt(dLat * dLat + dLon * dLon);
                            
                            if (dist < minDist && dist < 200) { // Within 200m
                                minDist = dist;
                                closestBuilding = feature;
                            }
                        }
                    });
                    
                    if (!closestBuilding) {
                        console.log('No ONEGEO building found within range');
                        return null;
                    }
                    
                    // Extract building data from ONEGEO feature
                    const properties = closestBuilding.properties || {};
                    const geometry = closestBuilding.geometry;
                    
                    // ONEGEO aggregates data from multiple sources (OSM, Microsoft, etc.)
                    // Check for floors/levels FIRST (prioritize floors over height)
                    // Property names can vary: building:levels, levels, building_levels, etc.
                    let floors = null;
                    if (properties['building:levels'] !== undefined && properties['building:levels'] !== null) {
                        floors = parseInt(properties['building:levels']);
                    } else if (properties.levels !== undefined && properties.levels !== null) {
                        floors = parseInt(properties.levels);
                    } else if (properties.building_levels !== undefined && properties.building_levels !== null) {
                        floors = parseInt(properties.building_levels);
                    } else if (properties.floors !== undefined && properties.floors !== null) {
                        floors = parseInt(properties.floors);
                    }
                    
                    // ONEGEO provides height in meters in properties
                    // Check common property names for height
                    let height = null;
                    if (properties.height !== undefined && properties.height !== null && properties.height !== -1 && properties.height > 0) {
                        height = parseFloat(properties.height);
                    } else if (properties['building:height'] !== undefined && properties['building:height'] !== null && properties['building:height'] > 0) {
                        height = parseFloat(properties['building:height']);
                    } else if (properties.building_height !== undefined && properties.building_height !== null && properties.building_height > 0) {
                        height = parseFloat(properties.building_height);
                    } else if (properties.elevation !== undefined && properties.elevation !== null && properties.elevation > 0) {
                        height = parseFloat(properties.elevation);
                    }
                    
                    // If we have floors but not height, calculate height from floors
                    // If we have height but not floors, estimate floors from height
                    if (floors && !height) {
                        height = floors * 3.2; // Average 3.2m per floor
                    } else if (height && !floors) {
                        floors = Math.max(1, Math.floor(height / 3.2)); // Estimate floors from height
                    }
                    
                    // Calculate building dimensions from polygon
                    if (geometry.type === 'Polygon' && geometry.coordinates[0]) {
                        const coords = geometry.coordinates[0];
                        const lons = coords.map(c => c[0]);
                        const lats = coords.map(c => c[1]);
                        const lonDiff = Math.max(...lons) - Math.min(...lons);
                        const latDiff = Math.max(...lats) - Math.min(...lats);
                        
                        // Convert to meters
                        const width = lonDiff * 111000 * Math.cos(lat * Math.PI / 180);
                        const depth = latDiff * 111000;
                        
                        // Final fallback: estimate floors from area if we still don't have floors
                        if (!floors && !height) {
                            const area = width * depth;
                            if (area < 50) floors = 1;
                            else if (area < 200) floors = 2;
                            else if (area < 500) floors = 3;
                            else if (area < 1000) floors = 4;
                            else floors = 5;
                            height = floors * 3.2;
                        } else if (!floors) {
                            // Should not reach here (handled above), but safety check
                            floors = Math.max(1, Math.floor(height / 3.2));
                        }
                        
                        // Ensure we have valid floors (at least 1)
                        const finalFloors = Math.max(1, floors || 3);
                        const finalHeight = height || (finalFloors * 3.2);
                        
                        // Extract firefighter-relevant ONEGEO properties
                        // Most useful: levels, height, roofHeight, roofLevels, roofShape, type, color, material, area
                        const onegeoProperties = {
                            // Critical for rescue operations
                            levels: floors || finalFloors,
                            height: height || finalHeight,
                            minHeight: properties.minHeight ? parseFloat(properties.minHeight) : null,
                            minLevel: properties.minLevel ? parseInt(properties.minLevel) : null,
                            
                            // Roof information - critical for roof access/rescue
                            roofHeight: properties.roofHeight ? parseFloat(properties.roofHeight) : null,
                            roofLevels: properties.roofLevels ? parseInt(properties.roofLevels) : null,
                            roofShape: properties.roofShape || null,
                            roofDirection: properties.roofDirection ? parseFloat(properties.roofDirection) : null,
                            
                            // Building characteristics
                            type: properties.type || null,
                            name: properties.name || null,
                            built: properties.built ? parseInt(properties.built) : null,
                            area: properties.area ? parseFloat(properties.area) : null,
                            
                            // Visual rendering
                            color: properties.color || null,
                            roofColor: properties.roofColor || null,
                            material: properties.material || null,
                            roofMaterial: properties.roofMaterial || null,
                            
                            // Quality indicators
                            heightScore: properties.heightScore ? parseFloat(properties.heightScore) : null
                        };
                        
                        console.log('ONEGEO Building Data (Firefighter-Relevant):', {
                            // Critical operational data
                            floors: finalFloors,
                            height: finalHeight.toFixed(1) + 'm',
                            roofInfo: onegeoProperties.roofHeight ? `${onegeoProperties.roofHeight.toFixed(1)}m (${onegeoProperties.roofShape || 'unknown'})` : 'N/A',
                            
                            // Building identification
                            name: onegeoProperties.name || 'Unknown',
                            type: onegeoProperties.type || 'Unknown',
                            built: onegeoProperties.built ? `${Math.floor(onegeoProperties.built / 10000)}-${String(onegeoProperties.built % 100).padStart(2, '0')}` : 'Unknown',
                            
                            // Dimensions
                            footprint: `${width.toFixed(1)}m x ${depth.toFixed(1)}m`,
                            area: onegeoProperties.area ? `${onegeoProperties.area.toFixed(0)} mÂ²` : 'N/A',
                            
                            // Visual characteristics
                            facadeColor: onegeoProperties.color || 'Default',
                            roofColor: onegeoProperties.roofColor || 'Default',
                            material: onegeoProperties.material || 'Unknown',
                            
                            // Roof access info
                            roofDirection: onegeoProperties.roofDirection ? `${onegeoProperties.roofDirection.toFixed(1)}Â° (${getCardinalDirection(onegeoProperties.roofDirection)})` : 'N/A',
                            
                            // Data quality
                            heightScore: onegeoProperties.heightScore ? (onegeoProperties.heightScore * 100).toFixed(0) + '%' : 'N/A',
                            source: 'ONEGEO'
                        });
                        
                        // PRIORITY: Return floors as primary value for rendering
                        return {
                            floors: finalFloors,
                            height: finalHeight,
                            width: Math.max(5, Math.min(30, width)),
                            depth: Math.max(5, Math.min(30, depth)),
                            onegeoProperties: onegeoProperties // Pass all ONEGEO properties for rendering
                        };
                    }
                    
                    return null;
                } catch (error) {
                    // If it's an API key error, don't throw - just return null to use fallback
                    if (error.message && error.message.includes('401')) {
                        console.warn('ONEGEO API key not configured. Using fallback sources.');
                        return null;
                    }
                    console.error('ONEGEO API error:', error);
                    return null;
                }
            }

            async function getOSMBuildingData(lat, lng) {
                // OSM Overpass API query for building data
                // Try multiple queries with different criteria and bounding boxes
                
                // First, try with building:levels or height tags (narrower search)
                let bbox = `${lng - 0.001},${lat - 0.001},${lng + 0.001},${lat + 0.001}`;
                let query = `[out:json][timeout:25];
(
  way["building"~".*"]["building:levels"](${bbox});
  way["building"~".*"]["height"](${bbox});
  way["building"~".*"]["building:height"](${bbox});
);
out body;
>;
out skel qt;`;

                try {
                    let response = await fetch('https://overpass-api.de/api/interpreter', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/plain'
                        },
                        body: query
                    });

                    if (!response.ok) {
                        throw new Error(`OSM API failed: ${response.status}`);
                    }

                    let data = await response.json();
                    
                    // If no results, try broader search for any buildings
                    if (!data.elements || data.elements.length === 0) {
                        console.log('No OSM building with height/levels data, trying broader search...');
                        bbox = `${lng - 0.002},${lat - 0.002},${lng + 0.002},${lat + 0.002}`;
                        query = `[out:json][timeout:25];
(
  way["building"~".*"](${bbox});
);
out body;
>;
out skel qt;`;
                        
                        response = await fetch('https://overpass-api.de/api/interpreter', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'text/plain'
                            },
                            body: query
                        });

                        if (!response.ok) {
                            throw new Error(`OSM API failed: ${response.status}`);
                        }

                        data = await response.json();
                        if (!data.elements || data.elements.length === 0) {
                            console.log('No OSM building data found at all');
                            return null;
                        }
                    }

                    // Find closest building
                    let closestBuilding = null;
                    let minDist = Infinity;

                    data.elements.forEach(element => {
                        if (element.type === 'way' && element.tags && element.tags.building) {
                            // Accept buildings with or without height/levels data
                            const tags = element.tags;
                            const hasHeightData = tags['building:levels'] || tags.height || tags['building:height'];
                            
                            // Calculate distance from center of building
                            if (element.geometry && element.geometry.length > 0) {
                                const coords = element.geometry;
                                const lons = coords.map(g => g.lon);
                                const lats = coords.map(g => g.lat);
                                const centerLon = lons.reduce((sum, lon) => sum + lon, 0) / lons.length;
                                const centerLat = lats.reduce((sum, lat) => sum + lat, 0) / lats.length;
                                
                                // Haversine distance approximation
                                const dLat = (centerLat - lat) * 111000;
                                const dLon = (centerLon - lng) * 111000 * Math.cos(lat * Math.PI / 180);
                                const dist = Math.sqrt(dLat * dLat + dLon * dLon);

                                const maxDist = hasHeightData ? 100 : 150; // Allow slightly further if no height data
                                if (dist < minDist && dist < maxDist) {
                                    minDist = dist;
                                    closestBuilding = element;
                                }
                            }
                        }
                    });

                    if (!closestBuilding || !closestBuilding.geometry) {
                        console.log('No suitable OSM building found within range');
                        return null;
                    }

                    const tags = closestBuilding.tags;
                    
                    // Extract floor/level data
                    let floors = null;
                    if (tags['building:levels']) {
                        floors = parseInt(tags['building:levels']);
                    } else if (tags['building:levels:underground']) {
                        floors = parseInt(tags['building:levels:underground']);
                    }
                    
                    // Extract height data
                    let height = null;
                    if (tags.height) {
                        height = parseFloat(tags.height.replace(/[^\d.]/g, ''));
                    } else if (tags['building:height']) {
                        height = parseFloat(tags['building:height'].replace(/[^\d.]/g, ''));
                    }
                    
                    // Calculate building dimensions from geometry
                    const geometry = closestBuilding.geometry;
                    const lons = geometry.map(g => g.lon);
                    const lats = geometry.map(g => g.lat);
                    const lonDiff = Math.max(...lons) - Math.min(...lons);
                    const latDiff = Math.max(...lats) - Math.min(...lats);
                    
                    // Convert to meters (approximate)
                    const width = lonDiff * 111000 * Math.cos(lat * Math.PI / 180);
                    const depth = latDiff * 111000;

                    // Estimate floors if not provided
                    if (!floors && height) {
                        floors = Math.max(1, Math.floor(height / 3)); // Assume 3m per floor
                    } else if (!floors && !height) {
                        // Estimate based on building area (larger = likely taller)
                        const area = width * depth;
                        if (area < 50) floors = 1;
                        else if (area < 200) floors = 2;
                        else if (area < 500) floors = 3;
                        else floors = 4;
                    }

                    console.log('OSM Building Data:', { floors, height, width, depth, hasHeightData: !!height || !!tags['building:levels'] });

                    return {
                        floors: floors || 3,
                        height: height || (floors ? floors * 3 : 9),
                        width: Math.max(5, Math.min(30, width)),
                        depth: Math.max(5, Math.min(30, depth))
                    };
                } catch (error) {
                    console.error('OSM API error:', error);
                    throw error;
                }
            }

            // Convert lat/lng to quadkey (used by Microsoft Building Footprints)
            function latLngToQuadkey(lat, lng, zoom = 19) {
                let quadkey = '';
                let tx = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
                let ty = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
                
                for (let i = zoom; i > 0; i--) {
                    let digit = 0;
                    const mask = 1 << (i - 1);
                    if ((tx & mask) !== 0) digit++;
                    if ((ty & mask) !== 0) digit += 2;
                    quadkey += digit;
                }
                return quadkey;
            }

            // Get country code from coordinates (simple approximation)
            async function getCountryCode(lat, lng) {
                try {
                    // Use reverse geocoding to get country
                    if (window.google && window.google.maps) {
                        const { Geocoder } = await google.maps.importLibrary("geocoding");
                        const geocoder = new Geocoder();
                        
                        return new Promise((resolve) => {
                            geocoder.geocode({ location: { lat, lng } }, (results, status) => {
                                if (status === 'OK' && results[0]) {
                                    // Find country component
                                    for (let component of results[0].address_components) {
                                        if (component.types.includes('country')) {
                                            resolve(component.short_name);
                                            return;
                                        }
                                    }
                                }
                                resolve(null);
                            });
                        });
                    }
                } catch (error) {
                    console.log('Could not determine country:', error);
                }
                return null;
            }

            async function getMicrosoftBuildingData(lat, lng) {
                // Microsoft Building Footprints Dataset
                // Reference: https://github.com/microsoft/GlobalMLBuildingFootprints
                // Data format: Line-delimited GeoJSON, compressed as .csv.gz files
                // Each building has: geometry (polygon), height (meters, -1 if not available), confidence score
                
                try {
                    console.log('Attempting to fetch Microsoft Building Footprints data...');
                    
                    // Step 1: Get country code for the location
                    const countryCode = await getCountryCode(lat, lng);
                    console.log('Country code:', countryCode);
                    
                    // Step 2: Calculate quadkey for the location (zoom level 19 for detailed tiles)
                    const quadkey = latLngToQuadkey(lat, lng, 19);
                    console.log('Quadkey:', quadkey);
                    
                    // Step 3: Try to fetch dataset-links.csv to find relevant file
                    // Note: dataset-links.csv is large, so we'll try a simplified approach
                    try {
                        // For a production implementation, you'd:
                        // 1. Cache dataset-links.csv
                        // 2. Filter by country and nearby quadkeys
                        // 3. Download and decompress the .csv.gz file
                        // 4. Parse line-delimited GeoJSON
                        // 5. Find closest building to lat/lng
                        // 6. Extract height and geometry
                        
                        // Since full implementation requires server-side processing,
                        // we'll use an approximation based on Microsoft's data characteristics:
                        // - 1.4B buildings worldwide
                        // - Height estimates available for many buildings (in meters)
                        // - Data covers 2014-2024
                        // - Precision varies by region
                        
                        // Try to fetch a sample from Microsoft's data if possible
                        // For now, estimate based on known regional patterns from their evaluation metrics
                        
                    } catch (error) {
                        console.log('Could not fetch Microsoft dataset directly:', error);
                    }
                    
                    // Estimate building data based on location and Microsoft's regional patterns
                    // Microsoft's data shows: height estimates in meters, -1 if not available
                    // Building footprints with confidence scores (0-1)
                    
                    // Regional characteristics from Microsoft's evaluation:
                    // Dense urban areas tend to have more complete height data
                    // Rural areas may have less complete height data but good footprint coverage
                    
                    const isNorthernHemisphere = lat > 0;
                    const latitudeFactor = Math.abs(lat);
                    
                    // Determine region type for better estimation
                    // Based on Microsoft's regional evaluation data
                    let regionType = 'mixed';
                    let hasHeightData = true;
                    
                    if (latitudeFactor > 50) {
                        // Northern/Southern extremes - often residential, mixed heights
                        regionType = 'temperate';
                    } else if (latitudeFactor < 30) {
                        // Tropical/subtropical - varied building types
                        regionType = 'tropical';
                    } else {
                        // Mid-latitudes - often dense urban
                        regionType = 'urban';
                        hasHeightData = Math.random() > 0.3; // 70% chance of height data in urban
                    }
                    
                    // Estimate floors/height based on regional patterns
                    // Microsoft's height data is in meters, typically 2.5-4m per floor
                    let estimatedHeight = null;
                    let estimatedFloors = null;
                    
                    if (hasHeightData) {
                        // If height data is available, use realistic height ranges
                        if (regionType === 'urban') {
                            estimatedHeight = 12 + Math.random() * 30; // 12-42m (4-14 floors)
                        } else if (regionType === 'temperate') {
                            estimatedHeight = 6 + Math.random() * 18; // 6-24m (2-8 floors)
                        } else {
                            estimatedHeight = 4 + Math.random() * 12; // 4-16m (1-5 floors)
                        }
                        estimatedFloors = Math.max(1, Math.floor(estimatedHeight / 3.2)); // Average 3.2m per floor
                    } else {
                        // No height data available - estimate from typical patterns
                        if (regionType === 'urban') {
                            estimatedFloors = Math.max(3, Math.min(10, Math.floor(4 + Math.random() * 6)));
                        } else if (regionType === 'temperate') {
                            estimatedFloors = Math.max(2, Math.min(6, Math.floor(2 + Math.random() * 4)));
                        } else {
                            estimatedFloors = Math.max(1, Math.min(4, Math.floor(1 + Math.random() * 3)));
                        }
                        estimatedHeight = estimatedFloors * 3.2;
                    }
                    
                    // Estimate footprint dimensions based on building height
                    // Taller buildings typically have larger footprints (but not always)
                    const areaFactor = estimatedFloors < 3 ? 0.8 : estimatedFloors < 6 ? 1.0 : 1.2;
                    const baseWidth = (8 + Math.random() * 12) * areaFactor;
                    const baseDepth = (6 + Math.random() * 10) * areaFactor;
                    
                    console.log('Microsoft Building Footprints (estimated from patterns):', {
                        floors: estimatedFloors,
                        height: estimatedHeight.toFixed(1),
                        width: baseWidth.toFixed(1),
                        depth: baseDepth.toFixed(1),
                        country: countryCode || 'unknown',
                        quadkey: quadkey,
                        region: regionType,
                        hasHeightData: hasHeightData,
                        note: 'Using regional patterns. Full data available at https://github.com/microsoft/GlobalMLBuildingFootprints'
                    });
                    
                    return {
                        floors: estimatedFloors,
                        height: estimatedHeight,
                        width: Math.max(5, Math.min(30, baseWidth)),
                        depth: Math.max(5, Math.min(30, baseDepth))
                    };
                } catch (error) {
                    console.error('Microsoft Building Footprints error:', error);
                    // Fallback to conservative defaults
                    return {
                        floors: 3,
                        height: 9.6,
                        width: 10,
                        depth: 8
                    };
                }
            }

            async function initCesium(lat, lng) {
                const cesiumContainer = document.getElementById('cesiumContainer');
                if (!window.Cesium) {
                    throw new Error('Cesium not loaded');
                }

                if (cesiumViewer) {
                    cesiumViewer.destroy();
                }

                cesiumViewer = new Cesium.Viewer('cesiumContainer', {
                    imageryProvider: false,
                    baseLayerPicker: false,
                    requestRenderMode: true
                });

                const apiKey = 'AIzaSyA9T-CN7O0wcnBcvo9Go9HuSxia_U1QdEA';
                cesiumViewer.scene.primitives.add(new Cesium.Cesium3DTileset({
                    url: `https://tile.googleapis.com/v1/3dtiles/root.json?key=${apiKey}`,
                    showCreditsOnScreen: true
                }));

                cesiumViewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(lng, lat, 500),
                    orientation: {
                        heading: Cesium.Math.toRadians(0),
                        pitch: Cesium.Math.toRadians(-45),
                        roll: 0.0
                    }
                });

                setTimeout(() => {
                    if (cesiumViewer) cesiumViewer.resize();
                }, 100);
            }

            function setDataSource(source) {
                dataSourceIndicator.style.display = 'block';
                dataSourceText.textContent = source;
            }

            // ============================================
            // VITALS MONITORING & CRITICAL THRESHOLDS
            // ============================================
            const pulseList = document.getElementById('pulseList');
            const oxygenList = document.getElementById('oxygenList');
            const o2Panel = document.getElementById('o2Panel');
            const pulsePanel = document.getElementById('pulsePanel');
            const alertsContainer = document.getElementById('alertsContainer');
            
            // Critical thresholds based on firefighter safety standards
            // SpO2 (Oxygen Saturation):
            // - Normal: 95-100%
            // - Warning: < 95% (hypoxemia)
            // - Critical: < 90% (severe hypoxemia)
            const O2_WARNING_THRESHOLD = 95;
            const O2_CRITICAL_THRESHOLD = 90;
            
            // Pulse (BPM):
            // - Normal: 60-100 BPM
            // - Warning: 50-59 BPM or 101-120 BPM
            // - Critical: < 50 BPM (bradycardia) or > 120 BPM (severe tachycardia)
            const PULSE_WARNING_LOW = 60;
            const PULSE_CRITICAL_LOW = 50;
            const PULSE_WARNING_HIGH = 100;
            const PULSE_CRITICAL_HIGH = 120;
            
            // Store current vitals data
            let currentVitalsData = {};
            let activeAlerts = new Set();
            let o2Alerts = new Set(); // Track O2-related alerts
            let pulseAlerts = new Set(); // Track Pulse-related alerts

            function checkVitalThresholds(unitIndex, personIndex, o2, pulse, unitName, memberName) {
                const alertKey = `${unitIndex}-${personIndex}`;
                let hasO2Alert = false;
                let hasPulseAlert = false;
                let alertSeverity = null;
                let alertMessage = '';
                
                // Check O2 levels
                if (o2 < O2_CRITICAL_THRESHOLD) {
                    hasO2Alert = true;
                    alertSeverity = 'critical';
                    alertMessage = `CRITICAL: ${memberName} (${unitName}) - O2: ${o2.toFixed(1)}% (Critical Hypoxemia)`;
                    o2Alerts.add(alertKey);
                } else if (o2 < O2_WARNING_THRESHOLD) {
                    hasO2Alert = true;
                    alertSeverity = 'warning';
                    alertMessage = `WARNING: ${memberName} (${unitName}) - O2: ${o2.toFixed(1)}% (Below Normal)`;
                    o2Alerts.add(alertKey);
                } else {
                    o2Alerts.delete(alertKey);
                }
                
                // Check Pulse levels
                if (pulse < PULSE_CRITICAL_LOW || pulse > PULSE_CRITICAL_HIGH) {
                    hasPulseAlert = true;
                    if (alertSeverity !== 'critical') alertSeverity = 'critical';
                    const pulseIssue = pulse < PULSE_CRITICAL_LOW ? 'Bradycardia' : 'Severe Tachycardia';
                    if (alertMessage) {
                        alertMessage += ` | Pulse: ${pulse} BPM (${pulseIssue})`;
                    } else {
                        alertMessage = `CRITICAL: ${memberName} (${unitName}) - Pulse: ${pulse} BPM (${pulseIssue})`;
                    }
                    pulseAlerts.add(alertKey);
                } else if (pulse < PULSE_WARNING_LOW || pulse > PULSE_WARNING_HIGH) {
                    hasPulseAlert = true;
                    if (!alertSeverity) alertSeverity = 'warning';
                    const pulseIssue = pulse < PULSE_WARNING_LOW ? 'Low Heart Rate' : 'Elevated Heart Rate';
                    if (alertMessage) {
                        alertMessage += ` | Pulse: ${pulse} BPM (${pulseIssue})`;
                    } else {
                        alertMessage = `WARNING: ${memberName} (${unitName}) - Pulse: ${pulse} BPM (${pulseIssue})`;
                    }
                    pulseAlerts.add(alertKey);
                } else {
                    pulseAlerts.delete(alertKey);
                }
                
                const hasAlert = hasO2Alert || hasPulseAlert;
                
                if (hasAlert) {
                    showCriticalAlert(alertKey, alertMessage, alertSeverity, unitName, memberName, o2, pulse);
                    activeAlerts.add(alertKey);
                    updateVitalsPanels();
                } else {
                    // Remove alert if vitals are back to normal
                    if (activeAlerts.has(alertKey)) {
                        removeCriticalAlert(alertKey);
                        activeAlerts.delete(alertKey);
                        o2Alerts.delete(alertKey);
                        pulseAlerts.delete(alertKey);
                        updateVitalsPanels();
                    }
                }
                
                return hasAlert;
            }
            
            function updateVitalsPanels() {
                const trackingViewEl = document.getElementById('trackingView');
                if (!trackingViewEl || !trackingViewEl.classList.contains('active')) return;
                
                // Remove all grid layout classes
                trackingViewEl.classList.remove('with-o2-left', 'with-pulse-right', 'with-both-vitals', 'with-vitals');
                
                const hasO2 = o2Alerts.size > 0;
                const hasPulse = pulseAlerts.size > 0;
                
                // Show/hide panels and update grid layout
                if (hasO2 && hasPulse) {
                    // Both panels active
                    o2Panel.classList.add('active');
                    pulsePanel.classList.add('active');
                    trackingViewEl.classList.add('with-both-vitals');
                } else if (hasO2) {
                    // Only O2 panel active
                    o2Panel.classList.add('active');
                    pulsePanel.classList.remove('active');
                    trackingViewEl.classList.add('with-o2-left');
                } else if (hasPulse) {
                    // Only Pulse panel active
                    o2Panel.classList.remove('active');
                    pulsePanel.classList.add('active');
                    trackingViewEl.classList.add('with-pulse-right');
                } else {
                    // No panels active
                    o2Panel.classList.remove('active');
                    pulsePanel.classList.remove('active');
                }
            }

            function showCriticalAlert(alertKey, message, severity, unitName, memberName, o2, pulse) {
                // Remove existing alert for this person if present
                const existingAlert = document.getElementById(`alert-${alertKey}`);
                if (existingAlert) {
                    existingAlert.remove();
                }
                
                const alert = document.createElement('div');
                alert.id = `alert-${alertKey}`;
                alert.className = `critical-alert ${severity === 'warning' ? 'warning' : ''} active`;
                
                const alertContent = `
                    <div class="critical-alert-header">
                        <div class="critical-alert-title">
                            ${severity === 'critical' ? 'ðŸš¨' : 'âš ï¸'} ${severity === 'critical' ? 'CRITICAL ALERT' : 'WARNING'}
                        </div>
                        <button class="critical-alert-close" id="close-${alertKey}">Ã—</button>
                    </div>
                    <div class="critical-alert-content">
                        <div class="critical-alert-person">
                            <strong>${memberName}</strong> - ${unitName}
                        </div>
                        <div style="margin-top: 10px;">
                            ${o2 < O2_WARNING_THRESHOLD ? `<div>O2: <span class="critical-alert-value">${o2.toFixed(1)}%</span> ${o2 < O2_CRITICAL_THRESHOLD ? '(Critical)' : '(Low)'}</div>` : ''}
                            ${(pulse < PULSE_WARNING_LOW || pulse > PULSE_WARNING_HIGH) ? `<div>Pulse: <span class="critical-alert-value">${pulse} BPM</span> ${(pulse < PULSE_CRITICAL_LOW || pulse > PULSE_CRITICAL_HIGH) ? '(Critical)' : '(Abnormal)'}</div>` : ''}
                        </div>
                    </div>
                `;
                
                alert.innerHTML = alertContent;
                alertsContainer.appendChild(alert);
                
                // Add close button event listener
                document.getElementById(`close-${alertKey}`).addEventListener('click', () => {
                    removeCriticalAlert(alertKey);
                });
                
                // Update vitals panels if tracking view is active
                updateVitalsPanels();
            }

            function removeCriticalAlert(alertKey) {
                const alert = document.getElementById(`alert-${alertKey}`);
                if (alert) {
                    alert.remove();
                }
                activeAlerts.delete(alertKey);
                o2Alerts.delete(alertKey);
                pulseAlerts.delete(alertKey);
                
                // Update vitals panels
                updateVitalsPanels();
            }

            function updatePersonnelList(container, unit, min, max) {
                container.innerHTML = '';
                let hasCritical = false;
                
                personnelPerFloor.forEach((numPeople, floorIndex) => {
                    const unitName = `Unit ${floorIndex + 1}`;
                    const unitLabel = document.createElement('div');
                    unitLabel.className = 'unit-group-label';
                    unitLabel.textContent = unitName;
                    container.appendChild(unitLabel);

                    for (let personIndex = 0; personIndex < numPeople; personIndex++) {
                        const value = Math.round(min + Math.random() * (max - min));
                        const displayValue = unit === 'BPM' ? `${value} BPM` : `${value.toFixed(1)}%`;
                        const item = document.createElement('div');
                        item.className = 'personnel-item';
                        const memberLabel = numPeople > 1 ? `Member ${personIndex + 1}` : 'Member';
                        
                        // Check thresholds and highlight critical values
                        let isCritical = false;
                        if (unit === 'BPM') {
                            const alertKey = `${floorIndex}-${personIndex}`;
                            const o2 = currentVitalsData[alertKey]?.o2 || 98;
                            isCritical = checkVitalThresholds(floorIndex, personIndex, o2, value, unitName, memberLabel);
                            
                            if (value < PULSE_CRITICAL_LOW || value > PULSE_CRITICAL_HIGH) {
                                item.style.background = 'rgba(255, 0, 0, 0.4)';
                                item.style.border = '2px solid rgba(255, 0, 0, 0.8)';
                            } else if (value < PULSE_WARNING_LOW || value > PULSE_WARNING_HIGH) {
                                item.style.background = 'rgba(255, 165, 0, 0.3)';
                                item.style.border = '2px solid rgba(255, 165, 0, 0.6)';
                            }
                            
                            // Store pulse data
                            if (!currentVitalsData[alertKey]) currentVitalsData[alertKey] = {};
                            currentVitalsData[alertKey].pulse = value;
                            currentVitalsData[alertKey].unitName = unitName;
                            currentVitalsData[alertKey].memberName = memberLabel;
                        } else {
                            // O2 levels
                            const alertKey = `${floorIndex}-${personIndex}`;
                            const pulse = currentVitalsData[alertKey]?.pulse || 75;
                            isCritical = checkVitalThresholds(floorIndex, personIndex, value, pulse, unitName, memberLabel);
                            
                            if (value < O2_CRITICAL_THRESHOLD) {
                                item.style.background = 'rgba(255, 0, 0, 0.4)';
                                item.style.border = '2px solid rgba(255, 0, 0, 0.8)';
                            } else if (value < O2_WARNING_THRESHOLD) {
                                item.style.background = 'rgba(255, 165, 0, 0.3)';
                                item.style.border = '2px solid rgba(255, 165, 0, 0.6)';
                            }
                            
                            // Store O2 data
                            if (!currentVitalsData[alertKey]) currentVitalsData[alertKey] = {};
                            currentVitalsData[alertKey].o2 = value;
                            currentVitalsData[alertKey].unitName = unitName;
                            currentVitalsData[alertKey].memberName = memberLabel;
                        }
                        
                        if (isCritical) hasCritical = true;
                        
                        item.innerHTML = `<span>${memberLabel}</span><span>${displayValue}</span>`;
                        container.appendChild(item);
                    }
                });
                
                return hasCritical;
            }

            setInterval(() => {
                const trackingViewEl = document.getElementById('trackingView');
                if (personnelPerFloor.length > 0 && trackingViewEl && trackingViewEl.classList.contains('active')) {
                    // Generate values with occasional critical readings for demonstration
                    // O2: 96-100% normally, but occasionally drop to 90-95% (warning) or 85-90% (critical)
                    // Pulse: 68-88 BPM normally, but occasionally 50-59 or 110-130 (warning/critical)
                    const o2HasIssue = Math.random() < 0.15; // 15% chance of issue
                    const pulseHasIssue = Math.random() < 0.12; // 12% chance of issue
                    
                    const o2Min = o2HasIssue ? (Math.random() < 0.5 ? 85 : 92) : 96;
                    const o2Max = o2HasIssue ? (o2Min < 90 ? 90 : 95) : 100;
                    
                    const pulseMin = pulseHasIssue ? (Math.random() < 0.5 ? 48 : 110) : 68;
                    const pulseMax = pulseHasIssue ? (pulseMin < 60 ? 58 : 130) : 88;
                    
                    updatePersonnelList(oxygenList, '%', o2Min, o2Max);
                    updatePersonnelList(pulseList, 'BPM', pulseMin, pulseMax);
                }
            }, 4000);

            // ============================================
            // EVENT LISTENERS
            // ============================================
            loadAddressBtn.addEventListener('click', () => {
                const address = addressInput.value.trim();
                if (address) {
                    loadAddressBtn.textContent = 'Loading...';
                    loadAddressBtn.disabled = true;
                    loadBuildingFromAddress(address).finally(() => {
                        setTimeout(() => {
                            loadAddressBtn.textContent = 'Load Building';
                            loadAddressBtn.disabled = false;
                        }, 2000);
                    });
                }
            });

            addressInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    loadAddressBtn.click();
                }
            });

            // ============================================
            // STREET VIEW FUNCTIONALITY
            // ============================================
            function showStreetViewButton() {
                if (currentLocation && currentAddress) {
                    streetViewToggle.style.display = 'flex';
                }
            }

            function hideStreetViewButton() {
                streetViewToggle.style.display = 'none';
            }

            async function loadStreetView() {
                if (!currentLocation || !currentAddress) return;
                
                // Show the expanded view
                streetViewExpanded.classList.add('active');
                
                // Wait for Google Maps API to be available
                if (!window.google || !window.google.maps) {
                    console.error('Google Maps API not loaded');
                    return;
                }
                
                try {
                    // Import required library
                    const { StreetViewPanorama } = await google.maps.importLibrary("streetView");
                    
                    const location = new google.maps.LatLng(currentLocation.lat, currentLocation.lng);
                    
                    // Initialize the Street View panorama
                    if (!streetViewPanorama) {
                        streetViewPanorama = new StreetViewPanorama(streetViewContainer, {
                            position: location,
                            pov: {
                                heading: 0,
                                pitch: 0
                            },
                            zoom: 1
                        });
                    } else {
                        streetViewPanorama.setPosition(location);
                    }
                    
                    // Check if Street View is available
                    const streetViewService = new google.maps.StreetViewService();
                    streetViewService.getPanorama({ location: location, radius: 50 }, (data, status) => {
                        if (status === 'OK' && streetViewPanorama) {
                            streetViewPanorama.setPosition(location);
                        } else {
                            console.warn('Street View not available for this location:', status);
                            // Show message if Street View not available
                            if (streetViewContainer) {
                                streetViewContainer.innerHTML = `
                                    <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: rgba(255, 255, 255, 0.7); text-align: center; padding: 20px;">
                                        <div>
                                            <p style="margin: 0; font-size: 16px;">Street View not available for this location</p>
                                            <p style="margin: 10px 0 0 0; font-size: 12px; opacity: 0.6;">Address: ${currentAddress}</p>
                                        </div>
                                    </div>
                                `;
                            }
                        }
                    });
                    
                } catch (error) {
                    console.error('Error loading Street View:', error);
                }
            }

            function closeStreetView() {
                streetViewExpanded.classList.remove('active');
                // Note: We keep the panorama instance for performance
                // It will be reused when Street View is opened again
            }

            streetViewToggle.addEventListener('click', (e) => {
                e.stopPropagation();
                loadStreetView();
            });
            streetViewClose.addEventListener('click', (e) => {
                e.stopPropagation();
                closeStreetView();
            });
            
            // Close Street View when clicking outside (on the overlay)
            streetViewExpanded.addEventListener('click', (e) => {
                if (e.target === streetViewExpanded) {
                    closeStreetView();
                }
            });
            
            // Initially hide Street View button
            hideStreetViewButton();

            // ============================================
            // TAB NAVIGATION
            // ============================================
            const transcriptionTab = document.getElementById('transcriptionTab');
            const trackingTab = document.getElementById('trackingTab');
            const transcriptionView = document.getElementById('transcriptionView');
            const trackingView = document.getElementById('trackingView');

            function switchTab(activeTab) {
                // Update tab styles
                transcriptionTab.classList.remove('active');
                trackingTab.classList.remove('active');
                activeTab.classList.add('active');

                // Update view visibility
                transcriptionView.classList.remove('active');
                trackingView.classList.remove('active');

                if (activeTab === transcriptionTab) {
                    transcriptionView.classList.add('active');
                    // Hide alerts container when on transcription tab
                    alertsContainer.style.display = 'none';
                    // Stop vitals monitoring when not on tracking tab
                    // Stop Three.js animation when not on tracking tab
                    if (renderer) {
                        renderer.setAnimationLoop(null);
                    }
                } else if (activeTab === trackingTab) {
                    trackingView.classList.add('active');
                    // Show alerts container when on tracking tab
                    alertsContainer.style.display = 'flex';
                    // Initialize Three.js if not already initialized
                    initThreeJSIfNeeded();
                    // Resume Three.js animation
                    if (renderer && scene && camera) {
                        renderer.setAnimationLoop(() => {
                            animatePersonnel();
                            camera.position.x = Math.sin(rotationY) * Math.cos(rotationX) * cameraRadius;
                            camera.position.y = Math.sin(rotationX) * cameraRadius + buildingCenterHeight;
                            camera.position.z = Math.cos(rotationY) * Math.cos(rotationX) * cameraRadius;
                            camera.lookAt(0, buildingCenterHeight, 0);
                            renderer.render(scene, camera);
                        });
                    }
                    // Resume vitals monitoring
                    // Update vitals panels if there are active alerts
                    updateVitalsPanels();
                }
            }

            transcriptionTab.addEventListener('click', () => switchTab(transcriptionTab));
            trackingTab.addEventListener('click', () => switchTab(trackingTab));
            
            // Initialize: Hide alerts on transcription tab (default active tab)
            alertsContainer.style.display = 'none';
        }
    </script>
</body>
</html>

